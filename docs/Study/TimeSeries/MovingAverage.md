# 时序预测：移动平均与加权移动平均

## 简单移动平均 (Simple Moving Average)

简单移动平均是一种**用最近的实际数据**来预测未来一个时期内产品需求的方法，它的特点是==简单、易用== 。如果产品需求不快速增长也不快速下降、不存在季节性因素时，移动平均能够有效消除预测中的随机波动。

考虑需求预测的场景。

我们用 $y_t$ 表示 $t$ 时刻的实际需求数据。用 $\hat{y}_{t+1|t}$ 表示 $t$ 时刻对 $t+1$ 时刻需求的预测值。假设我们用最近 $N$ 天（称为时间窗口）的数据来预测下一个时刻的需求，那么可以把移动平均法表示如下：

$$\hat{y}_{t+1|t} = \dfrac{(y_t + y_{t - 1} + y_{t-2} + ... + y_{t - N + 1} )}{N}$$

含义就是：我们用过去 $N$ 个实际需求的均值，当作下一个时刻的预测值。

![](https://ts1.cn.mm.bing.net/th/id/R-C.773315386dedb9aab4d1043b9beb6bc0?rik=upsE4gl7tyC76g&riu=http%3a%2f%2fwww.binarytribune.com%2fwp-content%2fuploads%2f2014%2f02%2fsimple_moving_average.jpg&ehk=PN8qOQtx7MFZrrU3TkDaH9bvDnOBB1p49lNkMkRR33E%3d&risl=&pid=ImgRaw&r=0)

> 比如，我们有如下所示的，长度为15的时间序列（省略时间戳）：
> 
> [10, 20, 30, 10, 30, 40, 20, 40, 50, 30, 40, 50, 10, 25, 35]
> 
> 我们人为规定，用过去 $5$ 个实际需求的均值作为下一个时刻的预测值，因此，我们可以给出对下一个时刻需求的预测值 $= \dfrac{（40 + 50 + 10 + 25 + 35）}{ 5 } = 32$ .

!!! note "但是，实际中我们往往无法直接知道该选过去多少个实际需求进行取均值操作，$N$ 作为一个参数，需要通过一些方法计算得出。这就需要进入调参的步骤。"

----

!!! question "样本内预测 / 样本外预测 (In- sample / out-of-sample Forecast)"
    - **样本内预测 （In-sample）**，利用估计出的模型对已有的样本进行预测，与样本数据进行比较。用于评估某个模型训练效果。比如，我有100天的数据，我截取前90天的数据训练模型，对未来10天进行预测（预测值），结果可以和原来100天数据的最后10个数据（真实值）进行比较，能够反映训练模型的优劣。

    - **样本外预测 (Out-of-Sample)**，利用估计的模型对未来进行预测。比如我有100天的数据，我训练出一个模型，确定参数，还不知道未来10天真实数据的情况下，对未来10天进行预测。这就是样本外预测。

### 简单移动平均法的调参


紧接上文，为了确定 $N$，首先需要给定时间窗口 $N$ 的最大值和最小值。因为：

1. 我们不希望包括太多过去的数据（$N$ 设置得太大），因为过早的历史数据不一定能反映当下的情况；
2. 我们也不希望只包含前一个周期的数据（ $N$ 设置得太小），因为过去一段时间的数据可能反映出整体的销售状况；

所以，算法开始前，需要指定 $N$ 的取值区间 $[ N_{\min}, N_{\max} ]$。作为参考，实际中可以取 $[3, 12]$。

> 现在我们用$$N \in [3,4]，$$以及长度15的时间序列
> 
> [10, 20, 30, 10, 30, 40, 20, 40, 50, 30, 40, 50, 10, 25, 35]
> 
> 来解释一下调参的过程。我们<u>选定测试集长度为1</u>，也就是假设我们基于倒数第2个时刻及其之前的数据，利用不同的参数，给出最后一个时刻的需求预测，然后比较不同参数 $N$ 下的预测结果。效果最好的那个参数 $N$，就是我们求出的最优参数。
> 
> > 1. 对于参数 $N = 3$, 我们预测最后一个时刻需求为: (50 + 10 + 25) / 3 = 28.33;
> > 2. 对于参数 $N = 4$，我们预测最后一个时刻需求为：(40 + 50 + 10 + 25) / 4 = 31.25;
> 
> 现在我们发现，最后一个时刻的实际需求是35，而 $N = 4$ 时预测值31.25明显更加接近真实值，所以我们认为最优参数是 $N = 4$。
> 
> 实际中，测试集长度往往会更长，（比如，3天/7天），这样可以更好地检验算法在一段时间内的预测效果，而不只是某一个时刻。同样地，对于预测效果的评价指标也可以很多元。

!!! question "One-Step Ahead Out-Of-Sample Forecast v.s. <br>Multi-Step Ahead Out-Of-Sample Forecast"
    一个显而易见的情形是，我们不止希望知道下一个时刻的需求，我们还想知道**未来一个时间段**内的需求是多少。前者，就是`One-Step Ahead Out-Of-Sample` ，后者，是 `Multi-Step Ahead Out-Of-Sample`。

    但是，移动平均需要过去某些时刻的真实值，如果对未来多个时刻预测，一些真实值还不知道。

    此时，往往将该时刻的预测值作为真实值，放入公式计算。

    > 例如，时间序列： [1,2,3,4,5,6,7]，假定时间戳是：`[2024-01, 2024-02, 2024-03, ..., 2024-07]`，我们选定 $N = 3$，要求给出未来3个周期 `(2024-08, 2024-09, 2024-10)` 的预测值。

    > 毫无疑问，`2024-08`的预测值 = (5 + 6 + 7) / 3 = 6；
    > 
    > 但是，`2024-09`的预测值，需要用到 `2024-08` 的真实值才能给出。可惜我们现在并不知道`2024-08`的真实值，只知道我们先前给出的预测值。
    > 
    > 于是，我们只能把`2024-08`的预测值当作真实值，放入公式计算 `2024-09` （其实还有`2024-10`）的预测值了。
    >
    > 因此，`2024-09`的预测值 = (6 + 7 + 6) / 3 = 6.33

    以此类推。


## 加权移动平均(Weighted Moving Average)

简单移动平均法给过去的 $N$ 个时刻的需求求均值，实际上赋予了每个需求相同的权重。但是，一般而言，**更靠近现在的实际需求往往比很久之前的实际需求更加具有代表性，也更能反映需求的短期变化趋势**。因此，通过给一个时间段内的实际需求赋予不同的权重，然后求加权后的均值，当作下一个时刻预测值的方法，就是加权移动平均法（Weighted Moving Average）。

依据简单移动平均里符号的含义，我们可以给出公式：

$$\hat{y}_{t+1|t} = \dfrac{ \sum \limits^{t}_{i = t-N+1} w_iy_i }{\sum \limits^{t}_{i = t - N + 1} w_i }$$

其中，$w_i$ 表示给第 $i$ 个时刻的实际需求赋予的权重。

注意到，如果 $w_i = 1$，那么这种算法就退化为了**简单移动平均**。

### 权重的确定方法

如何确定 $w_i$，是加权移动平均方法的重要步骤。下面介绍几种常见的加权方法。

#### 简单加权

假设我们已经给定 $N$ 的值。规定：

1. 当前时刻的真实值，赋予 $N$ 的权重，倒数第二个时刻的真实值，赋予 $N - 1$ 的权重，依次类推，那么倒数第 $N$ 时刻（也就是 $N-1$ 时刻前的真实值，赋予 $1$ 的权重；代入公式计算。即可。

> 比如，我们规定 $N = 5$, 过去5个时刻的需求分别为 
>  
> [10, 20, 10, 40, 50]，那么按照上述规则，每个时刻的权重为 [1, 2, 3, 4, 5]，再除以权重之和进行归一化，下一个时刻的需求就是:
> 
> $$\dfrac{(1 \times 10 + 2 \times 20 + 3 \times 10 + 4 \times 40 + 5 \times 50)} { 15 }  = 32.67$$.


#### 指数加权

假设我们已经给定时间窗口 $N$，我们记 $\alpha = \dfrac{2}{N+1}$，我们将 $(1 - \alpha)$ 作为参数权重；

1. 对于当前时刻的真实值（倒数第一个真实值），赋予权重 $1$， 
2. 对于倒数第二个真实值，赋予 $(1 - \alpha)$ 的权重，
3. 倒数第三个真实值，赋予 $(1 - \alpha)^2$ 的权重，
4. 以此类推，权重呈**指数增加**。距离现在最远的时刻，权重 $(1 - \alpha)^{N-1}$。

由于这种方式权重随着距离当前时刻越远，指数叠加，所以又称为指数加权。由于$\dfrac{2}{1 + N} < 1$ ，所以距离现在越远的时刻的真实值，权重越小。这符合我们预想的“历史数据会过时”的假设。

> 例如，我们规定 $N = 5$, 过去5个时刻的需求，**按照从远到近**，分别为:
> 
> [10, 20, 10, 40, 50]，
> 
> 那么按照上述规则，每个时刻的权重分别为 
> 
> $$[(\dfrac{2}{3})^4,  (\dfrac{2}{3})^3, \dfrac{2}{3}, (\dfrac{2}{3})^2,  1]$$
>
> 代入前述公式，可以得出，指数加权下，预测值为 34.17.

### 加权移动平均的调参

我们注意到，上述几种加权方法的参数设置**都与给定的窗口长度有关**。所以，我们可以仿照简单移动平均的方法，借助同样的历史数据，划分同样的测试集和训练集，比较不同长度窗口下，采用某种同样的加权方法，进行预测的结果，选出最好的 $N$，进行后续的预测。

> 比如，对于时间序列：
> 
> [10, 20, 30, 10, 30, 40, 20, 40, 50, 30, 40, 50, 10, 25, 35]，
> 
> 事先给定移动平均的窗口长度范围 [ min_window_width, max_window_width]，对于这个范围内的每一个可能的窗口长度，先算出权重系数 $\alpha$，然后对对应窗口内的每个实际需求进行加权平均，得到一个预测值。
> 
> 比较每个可能的时间窗口下的预测值，选出误差最小的，也就是默认的最优参数$N$（时间窗口长度）。计算过程省略。


当然，你可能会发现，有的场景下，简单移动平均也会获得不错甚至优于加权移动平均的结果，受此启发，我们可以同时使用**移动平均方法**以及**加权移动平均方法**进行预测，选出预测效果最好的那组方法，也即 "Pick Up The Best" 的过程。这在时间序列中也有一些应用。

