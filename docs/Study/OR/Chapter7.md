# 图论

- 如果一个图任意两点间至少存在一条链，那么这个图称为连通图；
- 连通且不含圈的无向图称为树；

## 最小生成树

### Prim算法

- 每次从没有选的边里选一条边，这个边权值要尽可能地小，使它和已有的不够成圈，直到选够 n - 1个边为止。


### Kruskal 算法

- 找每一个圈，把圈里最大的边删除掉，直到没有圈为止。

## 最短路问题

### Dijkstra 算法（单源最短路）

> 和动态规划问题不同，决策阶段不同，所以：

- 找到从某地到某地最短的路径：广度优先搜索解决赋权有向图或者无向图的单源最短路径问题；Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合，初始时，原点 s 的路径权重被赋为 0 。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
- 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 
- 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

!!! Tips 问题
    - 无法处理负权问题
    - 节点较多的话，计算量会加大


### Floyd算法 （多源最短路）

- Floyd算法又称为插点法，是一种利用**动态规划的思想**寻找给定的加权图中多源点之间最短路径的算法，

- 通过一个图的权值矩阵求出它的每两点间的最短路径矩阵。
- 我们的点如果在最短路上，那么我们用这个点去松弛最短路上的边的话，必定会松弛成功。因此，我们要想知道一个点在哪些点的最短路上，我们只需要用这个点去松弛所有边即可，松弛指的就是，把这个点作为一个“中转点”，遍历其出度和入度，如果距离更短就刷新图；
- 从一开始的邻接矩阵，遍历所有的节点，每次加入新结点都要更新==所有顶点之间的最短距离==，直到==所有顶点均可以作为中间顶点==之后（也就是对所有点都做了一次松弛），才算更新完毕，即可得到最终结果。


!!! Tips
    不能把负权加上最小的负数变整数这种做法，因为不是分阶段的问题，不能单纯地用DP的思想去解决。

    如果想要知道路径，还需要增加一个路由矩阵。

## 最大流问题

- 管道网络中每条边的最大通过能力（容量）是有限的，实际流量不超过容量。最大流问题(maximum flow problem)，一种组合最优化问题，就是要讨论如何充分利用装置的能力，使得运输的流量最大，以取得最好的效果。求最大流的标号算法最早由福特和福克逊于1956年提出，20世纪50年代福特(Ford)、福克逊(Fulkerson)建立的“网络流理论”，是网络应用的重要组成成分。
  
### Ford-Fulkson算法

## 最小费用流问题

- 输油管道，每个管道有运油量约束和成本，现在要从一个出发地运送特定数量的油到某个目的地，怎么运输，让成本最小



